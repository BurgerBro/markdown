## 变量

js中的变量可以分量两种类型：原始值和引用值。根据字面意思原始值指的是基本数据类型，引用值指的是复杂数据类型

> 变量在复制时原始值是值传递，引用值是引用传递。**但是作为函数参数时只有值传递一种**。

```javascript
function setAge(obj) {
	obj.age = 18
    obj = new Object()
    obj.age = 20
}
let jay = new Object()
setAge(jay)
console.log(jay.age) // 18 若为引用传递的话此处值为应为20
```



## 执行上下文与作用域

> 上下文可以理解一个变量对象的拥有者，js中最大的上下文是全局上下文，浏览器中全局上下文指的是window。
>
> 每个函数都有自己的上下文，当函数被执行时，该上下文会被放进上下文栈中，执行完毕后被弹出

## 内存

### 垃圾回收

> 垃圾回收有两种策略：标记清理和引用计数

 标记清理：当垃圾回收执行时，会标记所有内存中的变量，然后将上下文中的变量标记去掉，随后对仍有标记的变量进行清除

引用计数：对内存中的变量引用次数进行计数，当引用计数为0时则回收空间，但当存在循环引用时会导致内存泄漏

### 内存泄漏

> 常见导致内存泄漏的两种问题：
>
> 1. 声明变量未使用关键字
> 2. 函数闭包

```javascript
// 1
function setAge() {
    age = 1
}
// 2
function getName() {
    let name = 'qqq'
	return function() {
        return name
    }	
}
```

### 性能优化

> 间接控制垃圾回收机制，如自己创建一个对象池来控制对象的创建与销毁，避免垃圾回收机制频繁触发

**todo**: 实现一个对象池