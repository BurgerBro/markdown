# 正则表达式

这几天在刷算法题，刚好碰见几道题目使用正标表达式能够快速解题，而我对这一块知识并不熟悉，固特地学习一下这一专题。 正则表达式能够帮我们解决很多复杂的匹配问题，在写一些算法题时，使用正则表达式能够起到事半功倍的效果，让我们快速处理好数据。

正则表达式的核心就在于匹配模式，匹配字符或者匹配位置

## 1.模糊匹配

### 1.1横向模糊匹配

模糊匹配指的是匹配的字符串长度是不定的，实现方式是使用量词**{m,n}**，表示最少出现m次，最多出现n次

例如： **/qw{1,3}e/g**  可以匹配到的结果为 qwe，qwwe, qwwwe ，最后的g表示全局匹配

### 1.2纵向全局匹配

纵向模糊指的是，一个正则匹配的字符串，具体去匹配某一个位置的字符，该字符可以是不确定的

```javascript
let regex = /q[123]w/g
let str = "a0b a1b"
console.log(string.match(regex)) // ["a0b", "a1b"]
```

## 2.字符组

字符组指的是一组字符中的一个字符，例如[abc]，即表示"a", "b","c"

### 2.1范围表示法

0-9：[0-9] 

a-z：[a-z]

### 2.2排除字符组

^：反义字符

[^abc]：除了a,b,c之外的字符

### 2.3常见简写形式

\d就是[0-9]。表示一位数字。

\D：表示除数字外字符

\w: 数字字母下划线 [0-9a-zA-Z_]

\W：即上面的反义

\s: 表示空白符 [ \t\v\n\r\f]

\S：即上面的反义

.：通配符 `[^\n\r\u2028\u2029]`。通配符，表示几乎任意字符。换行符、回车符、行分隔符和段分隔符除外。

## 3.量词

### 3.1简写形式

>`**{m,}**` 表示至少出现m次。
>
>`**{m}**` 等价于`{m,m}`，表示出现m次。
>
>`**?**` 等价于`{0,1}`，表示出现或者不出现。记忆方式：问号的意思表示，有吗？
>
>`**+** `等价于`{1,}`，表示出现至少一次。记忆方式：加号是追加的意思，得先有一个，然后才考虑追加。
>
>`*****` 等价于`{0,}`，表示出现任意次，有可能不出现。记忆方式：看看天上的星星，可能一颗没有，可能零散有几颗，可能数也数不过来。



### 3.2 贪婪匹配和惰性匹配

一般来说没有特殊要求的匹配都是贪婪匹配，若要实现惰性匹配则再匹配语句后面加上？

例如： **/\d{2,5}?/**   表示的是2，5都行，但只要2个够了，就不会往下继续尝试。

## 4.多选分支

即使用管道符  **|** 进行分割

例如： 

```javascript
let regex = /good|goodbye/g
let str = "goodbye"
console.log(str.match(regex)) // good
let regex2 = /goodbye|good/g
let str2 = "goodbye"
console.log(str.match(regex)) // good
```



## 5.常用实例

- 匹配16进制颜色

```javascript
let regex = /#([0-9a-fA-F]{6}|[0-9a-fA-F]{3})/g
let str = "#ff00aa #FF11FF #000 #fab"
console.log( str.match(regex) )
```

- 匹配时间

```javascript
/**
23:22
09:12
*/
let regex = /^([01][0-9]|2[0-3]):[0-5][0-9]$/g
console.log( str.match(regex) )
```

- 匹配日期

  ```javascript
  2017-06-10
  var regex = /^[0-9]{4}-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$/;
  console.log( regex.test("2017-06-10") ); 
  // => true

  ```

  





